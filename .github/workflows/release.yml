name: "Manual Tauri Release"

on:
  workflow_dispatch:
    inputs:
      tag_name:
        description: "Git Tag for the Release (e.g., v1.0.0)"
        required: true
        type: string
      release_name:
        description: "Release title (e.g., App Name v1.0.0)"
        required: true
        type: string
      release_type:
        description: "Type of release (draft, private, public)"
        required: true
        type: choice
        options:
          - draft
          - private
          - public
      release_notes:
        description: "Release notes"
        required: false

jobs:
  # 1. Gets the application version for use in subsequent jobs and sets the stage for the release.
  setup:
    runs-on: ubuntu-latest
    outputs:
      app_version: ${{ steps.get_version.outputs.version }}
      release_upload_url: ${{ steps.create_release.outputs.upload_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Get App Version
        id: get_version
        run: |
          # Extract version from package.json for consistent naming
          APP_VERSION=$(node -p "require('./package.json').version")
          echo "version=$APP_VERSION" >> $GITHUB_OUTPUT

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.event.inputs.tag_name }}
          release_name: ${{ github.event.inputs.release_name }}
          body: ${{ github.event.inputs.release_notes }}
          # Prerelease logic: true if type is 'private', false otherwise.
          prerelease: ${{ github.event.inputs.release_type == 'private' }}
          # Draft logic: true if type is 'draft', false otherwise.
          draft: ${{ github.event.inputs.release_type == 'draft' }}

  # 2. Build for all platforms concurrently.
  build:
    name: Build for ${{ matrix.os }}
    needs: setup
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-22.04, macos-latest, windows-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"
          cache: "pip"

      - name: Install Python dependencies
        run: pip install fastapi uvicorn pydantic

      - name: Install pnpm and JS dependencies
        run: |
          corepack enable
          corepack prepare pnpm@9.15.4 --activate
          pnpm install

      # Run custom script to install any required python modules for sidecar bundling
      - name: Install sidecar Python requirements
        run: pnpm install-reqs

      - name: Install system dependencies for Linux
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.os == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: "./src-tauri -> target"

      - name: Build icons
        run: pnpm build:icons

      # The tauri build command handles the bundling of the sidecar based on tauri.conf.json
      # after any pre-build scripts (like pnpm build:sidecar-*) have run.
      # Assuming pnpm build:sidecar-* targets the correct Rust target directory.
      - name: Run Sidecar Pre-Build Scripts
        run: |
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            pnpm build:sidecar-linux
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            pnpm build:sidecar-macos
          elif [[ "${{ runner.os }}" == "Windows" ]]; then
            pnpm build:sidecar-winos
          fi

      # Use Tauri Action to perform the build and upload the temporary artifact
      - name: Build Tauri App and Upload Artifacts
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          # Tell the action to only build and upload to the workflow artifact,
          # not create a release yet (the separate setup job handles that)
          tagName: false
          releaseId: false
          uploadWorkflowArtifacts: true

  # 3. Collect all platform artifacts and upload them to the single release.
  upload_assets:
    name: Upload Assets to Release
    needs: [build, setup]
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Process and Upload Assets
        env:
          GITHUB_TOKEN: ${{ secrets.secrets.GITHUB_TOKEN }}
          RELEASE_UPLOAD_URL: ${{ needs.setup.outputs.release_upload_url }}
          APP_VERSION: ${{ needs.setup.outputs.app_version }}
        run: |
          # Install tool to easily upload all files
          sudo apt-get update && sudo apt-get install -y jq

          # Find all binary files (executables, installers, zips) produced by the build step
          find artifacts -type f | while read ASSET_PATH; do
            # Extract OS name from artifact path (e.g., 'windows-latest-artifact/windows-latest/installer.msi')
            OS_NAME=$(echo "$ASSET_PATH" | cut -d'/' -f2 | sed 's/-latest-artifact//')

            # Extract file extension for naming
            EXTENSION="${ASSET_PATH##*.}"

            # Create a consistent and clean name for the release asset
            ASSET_NAME="app_v${APP_VERSION}_${OS_NAME}_setup.${EXTENSION}"

            echo "Uploading $ASSET_PATH as $ASSET_NAME"

            # Use the official action to upload the processed asset
            curl -sL \
              -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Content-Type: $(file -b --mime-type "$ASSET_PATH")" \
              --data-binary "@$ASSET_PATH" \
              "$RELEASE_UPLOAD_URL?name=$ASSET_NAME"
          done
